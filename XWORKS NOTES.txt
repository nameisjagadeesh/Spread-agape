X-WORKZ CLASS NOTES 24/08/22
JAVA IS DEVELOPED BY JAMES GOSLING
java is high level object oriented programing language.
object oriented means a way to develop softeware
language is a means of communication
programming language is any language that is executed on computer system 
program is the decision , set of activity combined to perform a specific task
syntax in java is grammer to undertand n follow ,it is provides by pro lang
main purpose of devlopper is to maintain and the manage the user data
JDK:JAVA DEVELOPMENT KIT>WRITING PROGRAM>JAVA TO RUN PROGRAM;JAVAC TO CONVERT ENGLISH TO JAVA
JRE:JAVA RUNTIME ENV>RUN PROGRAM , JRE HAS JVM
JVM:JAVA VIRTUAL MACHINE>RUNS N EXCECUTE THE PROGRAM
JRE CONSIST OF JVM
JDK is basically a software development environment which is used to develop applications and applets.  jdk has tools and bins
JRE is a set of software tools which provides the run time environment , it contains set of liberaries
JRE is physical implementation of JVM as It provides a platform to execute java programs. jvm is responible for converting byte code into system specific instruction.

JAVA IS WIDELY USED PROGRAMMING LANGUAGE FOR CODING WEB APPLICATION
JAVAC COMPILES PROGRAM LANGUAGE INTO CLASS FILES THAT RUN ON THE JVM ,JAVAC USES JRE
features of java =simple,robust,platform independent,portability,java is WORA

platform is combinatiom of software n hardesware ex;ios n hardeware
java is platform independent
WORA -WRITE ONCE RUN ANYWHERE once compiled i
byte code is a special format which is understood by only JVM,CLASS=BYTE CODE
javac generates bytecode
developers writes source code
PLATFORM INDEPENDENT, IS JAVA COMPILED CODE (BYTE CODE) CAN RUN ON ALL OS
Datatype is a set of values and set of operations defined on those values .It defines what type of data and the size of data that is stored in a variable. ex=int size=56;
Variables are containers which stores the values. or variables are ref which points to the memory

JAVA IS OBJECT ORIENTED PROGRAMMING LANGUAGE,JAVA REPRESENTS REAL WORLD
OBJECT/class/things HAS STATES(DATA) AND BEHAVIOUR(ACTION)
jvm look for main method to execute
PUBLIC STATIC VOID MAIN(STRING[] ARG) =main method  =public is access specifier which is direct access to the jvm,static means direct access to the jvm without creating the object ,void is a return type and main is the name of the method which is searched by the jvm it is the method where the main execution occurs .String [] args is the parameter passed to the main method

main method is first method to start program
MEMORY RAM, HEAP MEMORY, META SPACE
HEAP TO EXECUTE JAVA PRO
CLASS LOADER IS A CLASS/object WHICH LOADS INFO OF CLASSES INTO META SPACE ,JVM USES CLASS LOADER
META SPACE IS TO LOAD CLASS INFO
STACK TO EXECUTE METHODS ,it will look for perticular mathod
CONSTANT POOL TO SToRE PREMITIVE
INSTANCE MEMORY TO STORE NON PREMITIVE
system.out.println(statement)> system:is class,. is a dot operator,out: static variable ,statement is args , println is static method , S should b in caps

output in java is information
use of writing program is to represent object ,
data=is variable.> ways/types=static,instance,local,parameter ,data is use to store data
declaring a variable=datatype refname(value)ex: Pizza pizza;
initialise a variable=by adding ;(semicolon which means end of statemnet)
datatype in java are 2 types =premitive n non premitive, premitive is to denote values, non primitive to compex value
types of primitive parameter(java dataypes)=byte ,short ,int , long ,float ,double, boolean, char

non primitive =any class we write is non premitive ,types=countless
any class will  have state and behaviour
local variable=declared within method body ,local variables cant be used without initialisation
pop=removing  a method
concatenation to add  which join results,adding strings together(+)
if two ref pointing to same memory we have to use "doble equals operater(==)" ,it will never check value

variable can never hold value it will only ref to adress
Scopes{}=using the data in a boundary ,ex;voter id scope is ward ,DL-nation with bigger scope passport;worldwide
wrapper classes=Object representation of primitive data type is called wrapper class.

reference is pointing to adress
variable is something which changes
ref variable which changes the adress
array is a collection of similara types of datatype or collection of variables of the same data type ,array is a container to store multiple data
array is non primitive ,any class is non premitive which has state n behaviour
primitive has no state and behaviour
array is group of reference of any dataypes(premitive or non premitive) array is also a data type "(datatype[] variablename}" ex=char []sizes;
[]is to hold multiple reference 
two ways to initialise array :{} or new keyword
index=length-1

string is a sequence of charecters=String =""
default value is given by jvm static n instance variable
local variable is one which is within main method
static, instance variable are class varibales
local and parameter are methods

null =which is pointing to no memory adress; it can be only non primitive
void=is return type which ref to no adress
return is use to stop the execution in any method
break is use to stop in loop
method is the set of statements;
parameter is a local variable which is declared within (),it can be initiated inside and outside,cant be declared before initialisation
local variable is declared within body only(inside),it can be initialised before declaration,
argument is a reference passed to method()

polymarphism is using same word in java to mean different things in differentcontext or (same thing but in different form)
2 types of polymarphism =compile time (overloading) and run time (overridding)
types of polymarphism=overloading-which is of same method but different in parameter ,overloading is a compile time polymarphism
variable can be initialised in 4 ways==literals,constructor,methods,class(or reference)

import of package
1. import statement : use classes from same package
2. in-line import : use when two classes with same name, from different package 
3. static import : to use static members without using class name 
4. wild card imports : use multiple classes from same package

copy : static has one copy n nonstatic has many copies
constructor is a special mathod ,it is same as class name ex:Bike() or Bike();  
constructor has no return type
constructor used with new key word
compiler will provides no-argument constructor
public Gold(){} is constructor type
public void Gold(){} is method type -instance method
instantiation is initiating the non primitive,it is making copies in instance memory
initialisation for primitive instance variables,instance creates many copies

New is a keyword which allocates the memory in instance and it used to create an object
instance creation/object creation ex =Song type=new Song;
Garbage Collection in java when ref is not pointing to any memory java (JVM) will automatically clear or recliams that memory
FQN=Fully Qualified Name is path+classname 

constructors are mainly used to initialise instance variable during instance creation ,Constructor gets called at the time of object creation.
types of constructor:1.default constructor(When user don’t define any constructor, compiler provides a default constructor.)
The access modifier of default constructor is same as that of the class.
2.custom constructor:User defined constructor is also known as custom constructor.The access modifier of custom constructor can be either public or protected or default or Private.
4 ways to initialise constructor =literals(default),reference(to update),constructor and methods
instance means copy			
constructor can be executed in stack ,constructor is not a member
if the constructors are marked as static, they can not be called from the child class;
this. is a keyword used when instance variable names and local variable names are same
this. keyword used in variable,methods,constructor
c programing language was developed by Dennis Richie
constructor chaining=when one constructor calls another constructor 
A copy constructor in a Java class is a constructor that creates an object using another object of the same Java class.
ex of copy constructor= constructor1{}        constructor2(){constructor1}

types of chaining=super(default/implicit::when calling from parent class) and this(calling from same class)
class level variable=static and non static
class variables=static 
any example we say is class,datatype,nonprimitive,object
F6 to execute one by one
F8 to close n come out
shortcut to declare and initialise constructor alr+shift+s+o/source in eclipse
Enum is a special class or datatype that represent a group of constants (which are unchangable variables like final variable)

Association in java is a connection or relation between two separate classes that are set up through their objects
relations are two types :: 1.inheritance(IS-A which is used for related things ex:Jagadeesh is good man) 
2.Association(HAS-A which is used for unrelated things ex: jagadeesh has a iphone)
null point exeptioner=when reference is not pointing to any memory and we try to access that variable
static can be accessed using the class name and reference but instance is accessed only by reference
Association types = composition:strong (where sub class cant exist without parent class  ex:fish and water) Aggregation :weak(where sub class can exist without parent class ex)

Access specifier control who can access and modify, it is  used at class , constructor, properties,method
4 access specifier: private (only inner class), protected(only inner class), default(only within same package ),  public(class , constructor, properties,method ,where it allows other classes from different package to access)
Magical package: these are default packages which dont need import , jre automatically imports
Access specifier provides the visibility 


ENCAPSULATION:: restricting direct access of properties and providing access using method

Class is a blueprint/or templet it contains variables and datatype
class loader is an object responible for loading the class ,it is a abstraction class
dot operater(.)is used to access thr instance variable and methods of class objects
for loop  =4 condition: initialization , condition check, checks if it is true and enter the loops and finally increament or decreament.
  

Inheritance means one class aquiring members(properties and methods) of another class
Inheritance ( extends keyword)
Parent ( has members).  Child ( is a class) Inheritance doesn’t need references
inheritance types =single,multilevel and heirarchial
in java multiple and hybrid inheritance is not possible ,for this we need interface
inheritance use is to overridding and re-usability(to avoid duplicate)  and to achieve polymarphism
Invisible parent is object and object is a superclass and object is in magical package  
any class we write is a part of object which is polymorphic in nameture(diff form)
casting=converting the parent reference to sub ckass(child class) only when parent ref is pointing to childclass ex:childclass name ref=(childclass name) parentclass ref OR "Creating an object of sub class and referring it by super class reference variable is called"
upcasting.
constructors are not inherited bcz they used to just initialisation of instance variable
java doesn’t support multiple inheritance by class but supports from interface
static members are inherited but cant be overriden

Class and parents terminologies 
childclass/subclass/derivedclass
Parent/superclass/baseclass

variable is a ref to address and it stores the value.
jvm decides which method to executes at run time(from parent or child) this is called as run time polymarphism
run time polymarphism(Or Dynamic method dispatch) achieved by overridding
overridding is compile time bcz compiler will check the errors during the method overridding(@overridding)
@(annotation) was introduced during java 1.5version ,it will check compile time errors.


Method :
What is a method ?
Ans :
→ A method is a set of instructions/statements or block of code which performs a specific task.
→ Method can return either primitive data or non primitive data.
→ Method can't return multiple primitive data types (eg : method can't return both int
and String at the same time).
→ But, It can return collection of homogeneous data type. ( eg : int[] array or String[]
array etc..)

When we use protected keyword we can initiate and create instance within same package but not possible to creat instance in different package, in different package it will be accessed by only inheritance but not accessed by reference 
2 ways to access constructor: by new keyword and by super chaining
Pointer is a kind of variable which points to memory of an address they are not used in java bcz they are unsecured 

We can’t override the static method bcz method overrridding is dynamic during run time and static methods are binded at compile time  but static methods can be inherited
final keyword used with class ,variable and method
By using final keyword at class level we can stop inheritance and cant be extended 
When we use make method as final we can inherit the method but can’t be overridden 
Out of 11 methods of object only 9 methods are accessed using reference

Hashcode used internally for hashing algorithms 
Equals method compare data of 2 objects(for non primitive) and == for primitive and non primitive data type 

String is immutable bcz it cant be inherited and modified (final)
2 ways to create string = littereal and with new keyword+

String has 65+11= 76 methods by default 
Internally string is represented as char[]
Constant pool never duplicates and instance memory can duplicate ( as we used with new keyword)

Interface bridge between 2 system(class) or rules allows two classes interact 
Interface is a keyword,non primitive datatype,cant declare constructor, cant create instances,declared as public (abstract,static,default)method, class only provides for implementation,it doesn’t support concrete methods(non static and non abstract),variables as public static final , it supports multiple inheritance 
Interface is 100% abstract and class is not 100% abstract(bcz class has both abstract and complete methods), class has methods with implementation but abstraction has no
Class has both abstract and concrete methods .
Interface is always public 
Interface used to achieve abstraction 
Class can implement n no of Interface but extend only one class
Instance creation is not possible for abstract class ,but  abstract class has default constructor
Abstraction class is completed using subclass 
Interface is also a incomplete and it is completed using implementation 
abstract class has default constructor but cant be used with new keyword ,only purpose is to chaining 
Parametrised constructor is mandatory in abstract class only when parent class has no default constructor 
One Interface extends another Interface or n no of interface
Marker Interface :it with no abstract methods
Java is pure objective oriented but it depends on developer how he uses it 
Ex: private int no; Or private Integere no;       We can use both things
instance creation is not possible in interface but we can creat implementation

EXCEPTIONAL EVENTS (Exception’s)
Events which stop the normal execution are called exceptional events 
Types : fix with change and fix without change
Throwable is parent most type to represent the exceptional issues
Throwable types : error and exception  both represents the exceptional events of class 
Error: system issue, memory issues , errors cant be recovered 
Exceptions : isssues in our program, data issues
Run time exceptions : logic issue
Throwable is not used bcz we cant distinguished between errors and exception
Throw keyword is used to declare the exceptional event ( ex=throw new RuntimeException();)

Keywords in java are something that has got a special meaning.
A variable is something that holds a value in the memory.
Static variables are also known as class variables.static means one single copy in the memory.
Static variables can be directly accessed from both static area and instance area.The scope of static variable is same as the scope of the class.
If we want common data to be shared across multiple objects, then we declare these data members as static variables.
Explain System.out.println(); =It is used to print a custom value on the console.Here, System is a predefined class in java.
‘out is a static object reference variable in System class,Println() is one of the non static method of PrintStream class which is actually responsible to print any custom value on the console.

array=Can store only homogenous data.Arrays are fixed, that is, when we declare an array, we must define the size.We can store duplicate values.We can also store null values.We can store both the address of an object and the actual object itself.

The process of automatic conversion of non primitive data type in to its corresponding primitive type by the compiler is called unboxing.
The process of automatic conversion of primitive data type in to its corresponding non primitive data type by the compiler is called autoboxing.

singleton class=is a class whose only one instance can be created at any given time in one jvm .a class can be made singleton by making its constructor private.

EXCEPTIONAL EVENTS (Exception’s)
Events which stop the normal execution are called exceptional events 
Types : fix with change and fix without change
Throwable is parent most type to represent the exceptional issues
Throwable types : error and exception  both represents the exceptional events of class 
Error: system issue, memory issues , errors cant be recovered 
Exceptions : isssues in our program, data issues
Run time exceptions : logic issue
Throwable is not used bcz we cant distinguished 
Throw keyword is used to create the exceptional event (throw new RuntimeException();)
Stack trace 
Throw will declare the exceptional event
Exceptional handlers: throws and tryblock
Error is an event and compilation error is a syntax problem
Compile time exception /checked exception: compiler is forcing u to handle issue
Run time exception/unchecked : compiler will not force u to handle issue
Jvm will create the exceptional 
Throws will delegate the exceptional claller of the method to handle the event
Compiler will uncheck event if it is sub class of RuntimeException 
Delegate means force creator to handle the method 
When we delegate to handle exception , use only sub class handlers , dont use parent type exception, throwable,error
Jvm tries to trace for the handler
Try block Handling the issue will make exceptions continue  ,try will help to come out of the exception and catch will handle it and continue the exception
types of tryblocks syntaxs;
1.try with resource                        try(){}
2.try(autoclosable)   
3.try with catch block                    try{} catch(type){} catch(type1){}
4.try with multiple catch block
5.try with finally block                  try{}  finally{}
6.try with catch and finally block        try{} catch(type){} finally{}
7.try with multi catch blocks             try{} catch(type|type1){}
8.try with multi catch blocks and finally block  
Jvm calls the catch block
Jvm will create exception at run time 
Finally (warranty )block will assured to always run it is assured by jvm , finally block helps to print important logics
System.exit(8) is the only method by which jvm gets killed  and finally will not executed,this method should not be used in industry 
Finally used to close the resource/ write a import logic.there is one scenario where the finally block does not execute. When you run System.exit(0) in the try or catch block, then finally block does not execute.

The stack trace, also called a backtrace, consists of a collection of stack records, which store an application's movement during its execution. The stack trace includes information about program subroutines and can be used to debug or troubleshoot and is often used to create log files

For loop is to access 
In interface only if we write default then we can write body
Class can be RuntimeException is by inheritance
Comple time exception created by extending exception 
Run time exception created by extending run time exception 

DTO - data transfer object it is a design pattern
It is a class it should only has datas not the methods
5 Rules
- [ ] Class should be non final
- [ ] Implements Serialisable( marker interface ) it taking the data from heap to permanent file
- [ ] All properties must be private
- [ ] It should have no arg constructor 
- [ ] It may have setter n getter methods
Audit properties of DTO
Properties 
Created by
Created date
Update by
Update date

Audit class must be abstract class bcz it is incomplete and we still dont know whose data it is ( create n update) , it is completed by sub class
We get FQN from toString method for that reference 

By using the repositoryname.super. Method name we can inherit the methods from sub class

Service: is a datatype/class which is used to write business logic and validation
Repository: to data store, methods to perform crud operation 
Tostring is to just display 

Collection 
collection is an interface used to represent the group of individual objects as a single entity
Collections is a class(java.util) in java using which we can sort the elements in collection
It is a class 
It is a customised non primitive data type 
It is a interface 
It is in the java.util
Jar files : collection of .class 
Arrays limitation ::operate over index only and it doesn’t have methods to operate 
Collection was introduced to address the limitations of arrays
Collection used to store thé references with methods
<E> is a diamond operator which is used to declare the generics ( similar data types)
We can’t store primitive datatypes in collections 
Use of collections: to group the reference 
Array list : allow the duplicates and follow insertion order
HashSet : dont allow the duplicates and not follow the order
Whenever we access the element by for each , always tostring method called (not fqn)
Loop accessing: for each(this is used when we are sure that collection are not modified), iterator , stream  
Iterator will. Allow access the elements from collection
This is used when the collection are modified and avoid the exception even after modifications 
Itertor has 3 methods:
boolean hasnext();
Elements next();
void remove();
Iterator follows the curser ( on top of array list) hasnext——-> next();
Concurrent modificationException is thrown when we used the for each and made the modification 
Iterator (); method will return iterator implementation type 
Iterator interface provides the facility of iterating the elements in a forward direction only.
Main advantage of collection: access it , searching, sorting n ordering easily 
Tostring it will represent an object as string
remove method internally works as equals method
Collection remove method returns boolean where it will check the ref and remove which is not guaranteed remove where as iterator remove method returns void which will guaranteed removal 
Contains method internally does equals method
Containsall, addall, remove all requaires the reference of collection
Collection.remove(obj) depends upon the equals method
Itr.remove(); doesn’t depends equals method 
Casting is done to access the properties of subclass 
Parameter of equals method is Object
Remove , contain, containall , removeall uses equals method
Collection works properly only when we override the equals method
List.add —-> it will add element to next index
List.set—-> it will replace the element wrt to that index
Ref added to collection is called elements 
Sql installation steps:
Custom-server-8.0-8.021-
Excecute

In stream method ,filter method is used when there is a condition to check
Lambda expression— ()->{}
Parameter is optional when a ref is only one
Body is optional when there is a one statements 
-> is mandatory 

Linked list: implementation of queue(circular queue, it works on node where one node is linked with other node
Linked list is slower while reading and   Faster while updating compared to arraylist which is faster while reading n slower while updating bcz it needs to update all the index
Linked list node: head-tail
Map :
￱it's an interface
￱used to store group of references in form of key & value
It works in the concept of dictionary 
￱key is unique & value can be duplicate
￱hierarchy : Map-->has subtype-SortedMap(TreeMap)
      implemented by HashTable & HashMap(LinkedHashMap)
Properties is also implementation of map
￱entry is an reference in map like element in collection 
￱methods :                                                  1)put - to add entry,                                 2)size - check capacity,                     3)isEmpty - to check entry presence, 4)keyset - to access only keys,                      5)values - only values access,         6)entrySet - access key & value together
￱declaring map in 2 ways - with generic & without
￱access 3 probabilities :                            1)only keys - keySet                                                    2)only values - values                                              3)both - entrySet
Sorting map: use treeMap implementation 
Map doesn’t have stream method

HashMap is non synchronized and not thread safe.On the other hand, Hashtable is thread safe and synchronized.
 HashMap allows one null key and any number of null values, while Hashtable do not allow null keys and null values in the Hashtable object. hashmap is fast and hashtable is slow

Serializable is the ability to transfering objects across the networks (storing the data from memory to permanent database)
comparator is a interface used for custom sorting.


in eclipse while creating new project we use classes/standards(folder name) instead of bin, bcz bin is for a windows standard ,but classes used to store the byte bytecode  

without initialisation local variable cant be used
A class is a group of objects which have common properties. It is a template or blueprint from which objects are created. It is a logical entity. It can't be physical.
Instance variable doesn't get memory at compile time. It gets memory at runtime when an object or instance is created. That is why it is known as an instance variable.

In java, we have 7 non-access modifiers. They are used with classes, methods, variables, constructors, etc to provide information about their behavior to JVM. They are as follows:static,final,abstract,synchronized,transient,volatile,native
Interface :
- it's a keyword
- it's a non-primitive data-type
- connection/bridge between 2 systems/classes.
- never use literal way to initialise.

StringBuffer is mutable means one can change the value of the object . The object created through StringBuffer is stored in the heap . StringBuffer  has the same methods as the StringBuilder , but each method in StringBuffer is synchronized that is StringBuffer is thread-safe. 
StringBuffer demo1 = new StringBuffer("Hello") ; ------->,demo1 = new StringBuffer("Bye"); 
 
StringBuilder  is same as the StringBuffer , that is it stores the object in heap and it can also be modified . The main difference between the StringBuffer and StringBuilder is that StringBuilder is  not thread safe. 
StringBuilder is fast as it is not thread safe.
StringBuffter and StringBuilder are mutable versions of string


Marker Interface :
- method without body 
- taking data from heap(temporary memory) to file(permanent memory) is Serializable, vice-versa is de-serializable
- ex : Serializable, randomAccess
transient keyword in Java is used to avoid Serialization.  If the variable is marked as transient then it will not be serialized.
If a variable is marked as volatile then this variable is read from the main memory instead of cache memory.

Functional Interface :
- interface with only one abstract method & can have static/default methods 
- syntax : interface Class name{
                abstract MethodName(); or void MethodName ();
                 }
- @FunctionalInterface annotation optional 
Lambda Expression : 
- ()->{}
- () to contain references based on parameters
- -> separates arguments from body
- used when there's functional Interface
- no data-type is specified
- passing a function as an argument
- based on parameters & return-type of method 
- body is optional but required when multiple parameter

collection.forEach method :
- used to loop all elements

SPRING: it is a framework to manage the objects
why spring? it is flexible,fast,productive,secure,supportive,manages objects easily.
Maven :
it is Project management tool 
It will be used to download the jar (libraries) files
Dependency are jar files from maven.

Spring
It is a framework , framework is a solution to common problems
Spring is not about coding its about configuration 
Spring is mainly used to manage objects 
Manage: create, initiate, destroy 
Bean is a object which is managed by spring 
Meta -info : is a data of external systems 
Meta-info~~ spring~~ bean
@configuration: making class as to provide configuration which passes the meta infor
@component: mark so that spring can manage object and create instances.
It will look for no argument constructor
@componetscan: to scan the component in perticular package , after that it will create instances  , it should be in configuration class
@bean is used when we have only .class files where u have to create class and spring will manage the object
@bean will register an object
@component is used when we have .java and spring will create and manage the object
Whenever a object manages other objects it is called as containing ex: Applicationcontext(interface)
Primary container/hierarchy of spring: beanFactory(core container , dont support AOP ) ApplicationContext(advanced container with more feature, does support AOP)-WebWpplicationContext (support webApplication development )
AOP: aspect oriented program
bean names: when we have two or more beans of same datatype
@bean is only used on top of the method , not constructor or class
@Value: to initialise the variable in string litteral here it can be loaded from outside class or file
It is used only for primitive, string n wrapper classes ,not for custom types
When we use java literals initialisation in spring (=“”) it will be hardcoded and cant load from outside class (file)
@value cant be used within the method and over the @ban
GetBean method: needs ref of container 
AutoWired method : needs component @autowired is annotation to get the ref of other bean managed by spring, it also initialise the bean of custom type
@Qualifier:to refer a bean by name 
tostring will loop and access the references
Spring is designed by following IOC(inversion of control) where the task is done by third party
IOC: Inverting the managing  of object via spring
DI: Dependency Injection , it is different from maven dependency 
It is getting the ref of an bject
It is done 2 ways : by property and constructor and also with setter
M2 folder in maven project is a repository 
$ in maven is a expression language
Spring is a DI framwork
When beans are combined together within the Spring container, they are said to be wired or the phenomenon is called bean wiring.
Primitive data types, Strings, and Classes can’t be autowired.
Quarkus and lombok
@notblank/notemply: for only string
@notnull:for for any non primitive 
Spring will not manage the dto class as the properties in dto will change
In industries SOP is not used as it cost performs as sop will use many processes in a system after coming out
Logger is used to print 
Server: is a computer which serves the resources 

Servlet- is a interface or a small java program which runs on web server
servlet hierarchy --- Servlet(5 methods)--->1.GenericServlet(one abstract method
                                            2.HttpServlet(no abstract methods) it better a subclass to extend this
200 code when resource is available 
404 : when resources is not available 
500:issues in resource 
2 types of server : computer and software 
Server : software and hardware 
Server: apache tomcat 9
Context : files in webapps tomcat 
To connect server:
http://localhost:8080/context/resourcename.extentions
Ex:http://169.254.51.3:8080/avatar/chocolate.png
Here https should not be used , http is for local network and https for secured one
http://google.com is. a vanity /f5 URL
google.com is a domain
google  is a domain name
.com is a domain type
Content-type/MIME type: img,mp3,pdf.. etc

Without form in html we cant call java program 
Tomcat container will manage object if it is a object of servlet (extends httpservlet)where as spring will manage all object
There should be no parametrised constructor in the servlet class as tomcat get confused which argument to pass
Tomcat will create only one object at one time and initiated properties only once and will call domethods n times
HTTP(): it will transfer the text(byte) over network 
POST(create), GET, PUT,DELETE method
Get method is defaultly called when server respond
Error 405 occurs when httpmethod is not equal to domethods of servlet
Service method will check the domethods
Tomcat act as bridge between servlet and client
Content directory: src/main/webapps where static files will be placed like html
Action in form is to map the servlet
Loadonstartup : tell server to create object on sequences 
First request: when we dont give loadonservlet , server will create on requests 
Requestparameters: url ? parameternames 
? It will separate the url and parameters 
Backward compatibility:
Server lifecycle: initi , service, destroy methods
Service starts when req is send 
Destroy called once when we shuttdown the server 
Init method to : to initiate the resource of servlet
Destroy method: to clear the resource of servlet
Req parameters: data we send to back
 


get method :carried in URL ,limited data(2020 characters ) ,it will load a resource
post method: carried in body ,un-limited data create the data send the data
JSP: Java Server Pages—-> html+ java
Jsp is a format which allows to write java , 
* It is a server side technology.
* It is used for creating web application.
* It is used to create dynamic web content.
* 
* JSP is a technology to create dynamic web applications while HTML is a standard markup language to create the structure of web pages.

after loading the jsp server will create java file
Requestforward: forwarding req from server to Jsp
SetAttribute is to send the data from server
HTTP is a stateless protocol bcz it will not remember client
Spring Web MVC(model view controller )
War : web archive
Inside src- java and test
Front controller : design pattern, is a servlet which maps all the req come to application
Ex: dispatcherServlet
@Data: lombok will create all getter, setter, tostring
@Getmapping will map the method
@requestmapping will map the class and send to server
Controller classes any class interacts with UI(user interface) and process the request , it will navigate the page
Webcontainer: will create component (controller) , Handlermapping(I),ViewResolver(I)
Hetswrveletconfigclassss method help to pass configuration classes to spring 
Model is to send the data to response 
Addattribute is : in keys and values
Error 500 in server is a exception in java program
If we use scriplet we have to write java in jsp
If we use JSTL( Java standard tag libs) we can use tags to get complex data
Getservletmapping: mapping action to dispatcherServlet.”/” which denotes action
Getservletconfig: helps spring container to create component 
Getrootconfigclass: listener
Only form actions will map the dispatcher selrvlet.
configuredefaultserverhandler:enabling server to handle static resources like html, css, pdf by default .
Dispatcher servlet will be managed by tomcat
Handlermapping: to find the controller in spring mvc , it will scan for the @requestmapping( key is always url and value is component)
controller: getmapping, postmapping. Wecan extract data from @requestparam or dto and returns the page name( index)
Viewresolver: it will resolve the view and find the page in webapps root
@component used for generic 
@service and @controller used for improved readability 

Connecting to DB
Client—-controller—— service——-repo—- storing in database
Database doesn’t know about object.here JPA(Java Persistence Api) will save the details of dto into database
Setup to connect to database
1.hibernate-core 
2.spring-orm
3.persistence.xml
4. Entity
5. Mysql drive
Sequel is a programming language (SQL)
Ada Lovelace : first programmer in the world
Protocol: vendor://host:portno/schema-name
User: root
For JDBC : mysqul://localhost:3306/schema-name
We keep credentials of database
@Entity: using this class we map the properties to DB —-@Entity @Table(name=“”) these coming from javax.persistence 
@Coloumn (name=“”)
@ID above property is to denote as primary key 
In service : we inject service into controller and invoke method of service in controller 
DTO: it is mapped with UI.
Entity: it will mapped with table(DB).
For a href link the method is always get
Figma is a UI tool
Bean called LocalcontainerEntityManagerFacyoryBean to create EntityManagerFactory (EMF)
Inject EMF to repository

JDBC (Java database connectivity) it is a API which connect java and database
Package: java.sql
We need interfaces and implementation of vendor jar files to connect to database.
Issues with JDBC: data is always in the form of object, JDBC understands only queries(sql) bcz objects has is-a and has-a relation where as jdbc has primary key and foreign key relation, cant store DTO directly to DB, we have to convert object in values,
to over come this ,JPA used  which will convert object of java to values and stores in DB
JPA will store and retrieve values from DB
ORM- object relation mapping .it is a guideline to map object to relational model.
Hibernate is a community to save object to DB .anybody solves 5 problems will be called ORM tool ex: Mybatis,Toplink,eclipselink
5 problems : association, inheritance,grain, navigation,identity 
JPA is a API provides standards to solve the ORM problems, it is implemented by hibernate 
JPA is a interface and hibernate is a implementation .
Hibernate is not used directly bcz if we change the vendor we have to change the code .
When we use JPA we can change vendor without changing the code.
Controller knows only dto
Repository knows only entity 
Service knows both

Spring MVC is request driven framework and one of the core components of the Spring framework.
It comes with ready to use loosely coupled components and elements that greatly aids developers in building flexible and robust web applications.
The MVC (Model - View - Controller) architecture separates and provides loose coupling between the different aspects of the application – input logic (Model), business logic (Controller), and UI logic (View).
DispatcherServlet  handles all the HTTP requests and responses.
The default ViewResolver used in Spring MVC is InternalResourceViewResolver
@Autowired annotation is meant for the injection of a bean by means of its type along with methods and fields.











